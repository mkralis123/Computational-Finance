import numpy as np
import matplotlib.pyplot as plt

def MCStockPrice(S0, sigma, t, integrator, rateCurve = [0.0179, 0.0177, 0.0182, 0.0181, 0.0173], samples = None):
    
    """
    ’S0’ is the stock prices at time t0.
    ‘sigma’ is the constant volatility.
    ‘rateCurve’ is an InterestRateCurve stored as a numpy array.
    ‘t’ is an array of fixing times ti, i = 1 . . . N to simulate to.
    ‘samples’ is an array of uniform random samples to use. The
    length of samples should be M × N where N is the number of
    fixing times and M is the number of paths.
    'M' is the number of paths
    integrator controls how the samples are generated according
    to the following value list
        ’standard’, where the paths are generated by using the
        solution of the Black-Scholes SDE step-by-step
        ’euler’, to use Euler-method integration of the BlackScholes SDE
        ’milstein’, to use Milstein-method integration of the BlackScholes SDE
    """
    M = 100
    
    T = 1
    
    if T >= 1:
        r = rateCurve[-1]
    elif T > 0.5:
        r = rateCurve[-1]
    elif T > 0.25:
        r = rateCurve[-2]
    elif T > (1/6):
        r = rateCurve[-3]
    elif T > (1/12):
        r = rateCurve[-4]
    else: 
        r = rateCurve[-5]
    
    N = len(t)
    price_array = np.empty((M, N))

    
    for i in range(N):
        
        num_ts = t[i]
        
            
        samples = np.random.randn(M, num_ts)
        
        if integrator == 'standard':
            
             standard_integration = S0*np.exp((r-0.5*sigma**2)*T + sigma*np.sqrt(T)*np.sum(samples,axis=1)/np.sqrt( num_ts ))
             
             price_array[:,i] = standard_integration
            
            
        elif integrator == 'euler':
            
            euler_integration = S0 * np.prod(1.+(r)*T/num_ts + sigma*np.sqrt(T/num_ts)*samples, axis=1)
            
            price_array[:,i] = euler_integration
            
        elif integrator == 'milstein':
            
            delStochCoeffdelAsset = sigma
            
            milstein_integration = S0*np.prod(1.+(r)*T/num_ts + sigma*np.sqrt(T/num_ts)*samples + 0.5*sigma*delStochCoeffdelAsset*(samples**2*T/num_ts-T/num_ts), axis=1)

            
            price_array[:,i] = milstein_integration
            
        else:
            return None
    
    
    """
    The function should return a numpy array of simulated stock prices
    having the same dimensions as samples.
    """
    
    return price_array

S0 = 50
m = 100
T = 1
sig = 0.5
r = 0.0173
t = [5,10,25,50,100]

test_standard = MCStockPrice(S0, sig, t , 'standard')
test_euler = MCStockPrice(S0, sig, t, 'euler')
test_milstein = MCStockPrice(S0, sig, t , 'milstein')


#The code below was used to generate graphs for the report
"""
checkpoints = [100,250,500, 1000]

sterr_at_checkpoints_standard = []
sterr_at_checkpoints_euler = []
sterr_at_checkpoints_milstein = []

for i in range(len(checkpoints)):
    sterr_at_checkpoints_standard.append(np.std(MCStockPrice(S0, sig, t , 'standard', checkpoints[i]))/np.sqrt(checkpoints[i]))
    sterr_at_checkpoints_euler.append(np.std(MCStockPrice(S0, sig, t, 'euler', checkpoints[i]))/np.sqrt(checkpoints[i]))
    sterr_at_checkpoints_milstein.append(np.std(MCStockPrice(S0, sig, t , 'milstein', checkpoints[i]))/np.sqrt(checkpoints[i]))

plt.figure(figsize = (10,5))
plt.title("Graph of Standard Error as M changes")
plt.plot(checkpoints, sterr_at_checkpoints_standard, label = 'Standard Scheme')
plt.plot(checkpoints, sterr_at_checkpoints_euler, label = 'Euler Scheme')
plt.plot(checkpoints, sterr_at_checkpoints_milstein, label = 'Milstein Scheme')
plt.xlabel('Number of Paths')
plt.ylabel('Standard Error')
plt.legend()
plt.show()



exactFwd = S0*np.exp(r*T)
standard_diff = np.mean(test_standard, axis = 0) - exactFwd
euler_diff = np.mean(test_euler, axis = 0) - exactFwd
milstein_diff = np.mean(test_milstein, axis = 0) - exactFwd

plt.figure(figsize = (10,5))
plt.title("Graph of Error from Forward Rate (M Fixed at 100)")
plt.plot(t, standard_diff, label = 'Standard Scheme')
plt.plot(t, euler_diff, label = 'Euler Scheme')
plt.plot(t, milstein_diff, label = 'Milstein Scheme')
plt.xlabel('Time Steps')
plt.ylabel('Error')
plt.legend()
plt.show()
"""